/***********************************************************
 * 第8章 排序
 ***********************************************************/

// 参考来源：
// 1. 课本：《数据结构 C语言第二版》by 严蔚敏
// 2. 视频：b站视频《数据结构》by王卓

//导入相关的头文件
# include <stdio.h> // 标准输入输出流
# include <iostream> // 输入输出流
# include <fstream>  // 文件输入输出流
# include <cstring>  // 字符串操作函数
using namespace std; // 使用标准命名空间   
// Status定义
#define OK 1
#define ERROR 0 
#define OVERFLOW -2
#define True 1
#define False 0
typedef int Status; // Status是函数的类型，其值是函数结果状态代码

#define MAXSIZE 20 // 顺序表的最大长度
typedef int KeyType; // 关键字类型。暂时假设为int类型
typedef int InfoType; // 其他数据域类型。暂时假设为int类型
typedef struct RedType{ // 记录类型
    KeyType key; // 关键字类型
    InfoType otherinfo; // 其他数据域
} RedType; // RedType是线性表的元素类型，包含关键字和其他数据域。KeyType是关键字类型。
typedef struct SqList{ // 顺序表类型
    RedType r[MAXSIZE+1]; // r[0]闲置或者做哨兵。r[1]~r[length]是线性表的元素
    int length; // 线性表的长度
} SqList; // SqList是顺序表，包含关键字和其他数据域。RedType是线性表的元素类型，包含关键字和其他数据域。


/*==============================================================
* 8.2 插入排序
- 基本思想：将一个记录插入到已经排好序的序列中，保持序列的有序性。（相当于扑克牌抓牌）
 *==============================================================*/


 /* -------------- 8.2.1 直接插入排序（Straight Insertion Sort）--------------- */

// 【算法8.1】直接插入排序
// 参考视频：第14周02--第8章排序2--8.2插入排序1--直接插入排序 https://www.bilibili.com/video/BV1nJ411V7bd?vd_source=b53bd15b89ae068fd295b2d36a386a97&spm_id_from=333.788.videopod.episodes&p=160
// 参考课本：p2237-p238
// 时间复杂度:
//  - 最好：O(n)（顺序），
//  - 最坏：O(n^2)（逆序），
//  - 平均：O(n^2)（无序）。
// 空间复杂度：O(1)（只需要常数级的辅助空间）。
// 基本思路：将一个记录插入到已经排好序的序列中，保持序列的有序性，用到顺序查找法。
// 排序稳定性：稳定。
// 性能对于顺序、无序、逆序的区别：顺序最好，O(n)；无序次之，O(n^2)；逆序最差，O(n^2)。
// 存储结构：可以用顺序存储结构，也可以用链式存储结构。
// 适用情况：初始记录有序或者基本有序，n较小的情况。

void InsertSort(SqList &L){
    // 对顺序表L进行直接插入排序
    int i,j;
    for(i=2; i<=L.length; ++i){ // 从第2个元素开始(第1个不需要比较)，依次插入到前面已经排好序的部分。（将r[i]与r[i-1],r[i-2],...,r[1]进行从后往前的比较）
        if(L.r[i].key < L.r[i-1].key){ // 如果当前元素小于前一个元素，则进行插入排序。否则保留在原位置，不需要交换。（然后继续for循环）
            L.r[0] = L.r[i]; // 将当前元素保存到哨兵位置
            // L.r[i] = L.r[i-1]; // 将r[i-1]后移一位。
            // for (j=i-2; L.r[0].key < L.r[j].key; --j){ // 从后向前查找插入位置。注意是从j=i-2开始，因为涉及到[j+1]的赋值。
            //     L.r[j+1] = L.r[j]; // 如果当前元素小于前一个元素，则将前一个元素r[j]后移一位。（逐个后移直到找到插入位置）
            //     // 此时遇到哨兵元素L.r[0]（即j=0时），就自动停止了，因为L.r[0].key == L.r[j].key。
            // }
            // 以上5行是教材的代码，但是我认为可以简化成下面的4行，这样也方便和其他插入排序算法统一一下j的初始值为i-1：
            for(j=i-1; L.r[0].key < L.r[j].key; --j){ // 从后向前查找插入位置。注意是从j=i-1开始，因为涉及到[j+1]的赋值。
                L.r[j+1] = L.r[j]; // 如果当前元素小于前一个元素，则将前一个元素r[j]后移一位。（逐个后移直到找到插入位置）
                // 此时遇到哨兵元素L.r[0]（即j=0时），就自动停止了，因为L.r[0].key == L.r[j].key。
            }
            // 可以看出除了哨兵节点的赋值之外，其他的赋值（即元素的移动）都是索引下标更小的元素往后移动一位，赋值给索引下标更大的元素。
            L.r[j+1] = L.r[0]; // 将哨兵元素插入到正确的位置。注意是j+1不是j，因为j已经经历了一次--j。
        }
    }
}

 /* -------------- 8.2.2 折半插入排序(Binary Insertion Sort)--------------- */

// 【算法8.2】折半插入排序（二分插入排序）
// 参考视频：第14周03--第8章排序3--8.2插入排序2--折半插入排序 https://www.bilibili.com/video/BV1nJ411V7bd?vd_source=b53bd15b89ae068fd295b2d36a386a97&spm_id_from=333.788.videopod.episodes&p=161
// 参考课本：p238-p239
// 时间复杂度:
//  - 最好：O(nlogn)（顺序），
//  - 最坏：O(n^2)（逆序），
//  - 平均：O(n^2)（无序）。
// 空间复杂度：O(1)（只需要常数级的辅助空间）。
// 基本思路：将一个记录插入到已经排好序的序列中，保持序列的有序性，用到二分查找法。（算是对直接插入排序的改进）
// 排序稳定性：稳定。
// 性能对于顺序、无序、逆序的区别：没有区别。如果是基本顺序，那么关键字比较次数反而比直接插入排序要多。
// 存储结构：不能用链式存储结构，因为链式存储结构没有随机访问的特性，不能用二分查找法。
// 适用情况：初始记录无序，n较大的情况

void BInsertSort(SqList &L){
    // 对顺序表L进行折半插入排序
    int i,j,low,high,mid;
    for(i=2; i<=L.length; ++i){ // 从第2个元素开始(第1个不需要比较)，依次插入到前面已经排好序的部分。
        L.r[0] = L.r[i]; // 将当前元素保存到哨兵位置
        // 下面用折半（二分）查找法查找插入位置（替代顺序查找法）
        low = 1; high = i-1; // low和high分别是查找范围的下限和上限，相当于在r[1]~r[i-1]中查找插入位置。
        while(low <= high){ // 二分查找插入位置
            mid = low + (high-low) / 2; // 取中间位置
            if(L.r[0].key < L.r[mid].key) high = mid - 1; // 如果当前元素小于中间元素，则在左半部分查找
            else low = mid + 1; // 如果当前元素大于中间元素，则在右半部分查找
        } // 循环结束，high+1是插入位置
        // 因为最后一次while循环时，mid=low=high, 如果r[0].key < r[mid].key, 则high=mid-1, 此时应该插入到mid也就是high+1的位置；
        //      如果r[0].key >= r[mid].key, 则low=mid+1, 此时应该插入到mid+1也就是high+1的位置。
        //      这种if和else的先后顺序（先用<号赋值high，然后再用≥号赋值low)也能保持排序的稳定性。
        for(j=i-1; j>=high+1; --j){ // 将r[high+1]到r[i-1]的元素都往后移动一位，变成r[high+2]到r[i]。
            L.r[j+1] = L.r[j]; 
            // 此时遇到哨兵元素L.r[0]（即j=0时），就自动停止了，因为L.r[0].key == L.r[j].key。
        } // 注意是j=i-1而不是i-2，因为BInsertSort没有像InsertSort一样，一开始就进行了L.r[i] = L.r[i-1]的赋值。
        L.r[high+1] = L.r[0]; // 将哨兵元素插入到正确的位置。注意是high+1不是high。此时其实high+1=j+1。
    }
}
    
/* -------------- 8.2.3 希尔排序（Shell Sort）--------------- */

// 【算法8.3】希尔排序（Shell Sort）
// 参考视频：第14周04--第8章排序4--8.2插入排序3--希尔排序 https://www.bilibili.com/video/BV1nJ411V7bd?vd_source=b53bd15b89ae068fd295b2d36a386a97&spm_id_from=333.788.player.switch&p=162
// 参考课本：p239-p241
// 时间复杂度：O(n^1.25)，空间复杂度：O(1)。
// 基本思路：是对直接插入排序的改进，先将整个待排元素序列分割成若干个子序列分别进行直接插入排序，在最后一次直接插入排序时，整个序列是基本有序的，能近似实现直接插入排序的最佳性能（O(n)）。
// 排序稳定性：不稳定。
// 性能对于顺序、无序、逆序的区别：没有区别。
// 存储结构：不能用链式存储结构，因为链式存储结构没有随机访问的特性，不方便跳着增量访问元素。
// 适用情况：初始记录无序，n较大的情况。

void ShellInsert(SqList &L, int dk){
    // 对顺序表L做1趟增量（步长）是dk的希尔插入排序。
    int i,j; // i是当前元素，j是前一个元素
    // 以下内容相当于直接插入排序的改进，只不过将dk从1抽象成了一个变量dt。
    for(i=dk+1; i<=L.length; ++i){ // 从第dk+1个元素开始(前面已经排好序的部分)，依次插入到前面已经排好序的部分。
        if(L.r[i].key < L.r[i-dk].key){ // 将L.r[i]插入有序增量子表。
            L.r[0] = L.r[i]; // 将当前元素暂存到L.r[0]。此时L.r[0]没有起到哨兵的作用，只是暂存。
            for(j=i-dk; j>0 && L.r[0].key < L.r[j].key; j-=dk){ // 从后向前查找插入位置。注意是从j=i-dk开始，因为涉及到[j+dk]的赋值。
                // 注意额外添加了一个条件j>0, 这样可以避免j<0时访问越界（因为此时dk!=1, L.r[0]失去了哨兵的作用）。
                L.r[j+dk] = L.r[j]; // 如果当前元素小于前一个元素，则将前一个元素r[j]后移dk位。
            }
            L.r[j+dk] = L.r[0]; // 将r[0]也就是原来的L.r[i]插入到正确的位置。注意是j+dk不是j，因为j已经经历了一次-dk。
        }
    }
}
void ShellSort(SqList &L, int dlta[], int t){
    // 按照增量序列dlta[]对顺序表L进行t趟希尔排序。
    // dlta[]是增量序列，t是增量序列的长度。dlta[0]>dlta[1]>...>dlta[t-1]=1,且 dlta所有元素互质。
    int i,j,k,dk; // dk是当前增量
    for(k=0; k<t; ++k){ // 遍历增量序列
        ShellInsert(L, dlta[k]); // 对顺序表L进行希尔排序
    }
}



/*==============================================================
* 8.3 交换排序
- 基本思想：通过交换相邻元素的方式进行排序。
 *==============================================================*/

/* -------------- 8.3.1 冒泡排序（Bubble Sort）--------------- */

// 【算法8.4】冒泡排序（Bubble Sort）
// 参考视频：第14周05--第8章排序5--8.3交换排序1--冒泡排序 https://www.bilibili.com/video/BV1nJ411V7bd?vd_source=b53bd15b89ae068fd295b2d36a386a97&spm_id_from=333.788.player.switch&p=163
// 参考课本：p241-p243
// 时间复杂度：O(n^2)，空间复杂度：O(1)。平均性能比 直接插入排序还差。
// 基本思路：通过交换相邻元素的方式进行排序。
// 排序稳定性：稳定。
// 性能对于顺序、无序、逆序的区别：顺序最好，O(n)；无序次之，O(n^2)；逆序最差，O(n^2)。
// 存储结构：可以用顺序存储结构，也可以用链式存储结构。

// 辅助函数swap：交换两个元素的值
void swap(RedType &a, RedType &b){
    // 交换两个元素的值
    RedType temp = a; // 用一个临时变量保存a的值
    a = b; // 将b的值赋给a
    b = temp; // 将temp的值赋给b
}

// 正式开始
void BubbleSort(SqList &L){
    // 对顺序表L进行冒泡排序
    int j; // j是循环变量
    int flag=1;// flag是标志变量，表示是否发生交换, 1表示发生交换，0表示没有发生交换，初始化为1。
    int m = L.length-1; 
    while(flag&& m>0){ // 如果发生交换，继续循环；如果没有发生交换，说明已经排好序了，退出循环。
        flag = 0; // 初始化标志变量为0
        for(j=1; j<=m; ++j){ // 从第1个元素开始，依次比较相邻的两个元素
            if(L.r[j].key > L.r[j+1].key){ // 如果前一个元素大于后一个元素，则交换位置
                swap(L.r[j], L.r[j+1]); // 交换相邻的两个元素
                flag = 1; // 发生交换，标志变量设为1
            }
        }
        --m; // 每次循环结束后，最大的元素已经排好序了，所以下次循环只需要比较[1,m-1]的元素即可。
    }
}

/* -------------- 8.3.2 快速排序（Quick Sort）--------------- */

// 【算法8.5】快速排序（Quick Sort）
// 参考视频：第14周06--第8章排序6--8.3交换排序2--快速排序1 https://www.bilibili.com/video/BV1nJ411V7bd?vd_source=b53bd15b89ae068fd295b2d36a386a97&spm_id_from=333.788.player.switch&p=164
// 参考课本：p243-p245
// 时间复杂度：
//  - 最好：O(nlogn)（每趟排序都能将序列分成两个近似相等的子序列）
//  - 最坏：O(n^2)（有序或者近似有序，逆序或者顺序都是），退化到简单选择排序的水平。
//  - 平均：O(nlogn)（无序）。
// 空间复杂度： 最大递归调用次数与递归树的深度一致。
//  - 最好： O(logn)（每趟排序都能将序列分成两个近似相等的子序列）
//  - 最坏： O(n)（有序或者近似有序，逆序或者顺序都是，此时递归树变成单支树，深度为n）。
// 基本思路：是对冒泡排序的改进，采用分治法，将待排序序列分成两个子序列，分别进行排序，直到子序列的长度为1。用到双指针法。
// 排序稳定性：不稳定。
// 性能对于顺序、无序、逆序的区别：有序（顺序或者逆序）时性能最差，O(n^2)；无序时性能最好，O(nlogn)。
// 存储结构：适用于顺序存储结构，很难用于链式存储结构，因为涉及到定位表的上下界。
// 适用情况：初始记录无序，n较大的情况。
// ！！！注意：在平均情况下，快速排序是所有内部排序算法中速度最快的。

int Partition(SqList &L, int low, int high){
    // 对顺序表L的子表L.r[low]~L.r[high]进行1趟排序，并返回枢轴的下标
    // 选择第一个元素作为基准元素
    L.r[0] = L.r[low]; // 将第一个元素保存到哨兵位置
    KeyType pivotkey = L.r[low].key; // 基准元素的关键字
    while(low < high){ // 当low小于high时，继续循环。用low和high双指针反复交换元素，即从表的两端交替地向中间扫描。
        while(low < high && L.r[high].key >= pivotkey) --high; // 从右向左查找第一个小于基准元素的元素
        L.r[low] = L.r[high]; // 将该元素赋值给low位置
        while(low < high && L.r[low].key <= pivotkey) ++low; // 从左向右查找第一个大于基准元素的元素
        L.r[high] = L.r[low]; // 将该元素赋值给high位置
    } // 此处会导致排序不稳定。
    L.r[low] = L.r[0]; // 将基准元素赋值给low位置。此时low ==high，表示基准元素已经找到位置了。
    return low; // 返回基准元素的下标
}
void QSort(SqList &L, int low, int high){
    // 调用前置初始值：low=1, high=L.length
    // 对顺序表L的子表L.r[low]~L.r[high]进行快速排序,用到Partition函数
    if(low<high){
        int pivotloc = Partition(L, low, high); // 将L.r[low]~L.r[high]划分成两个子表，pivotloc是枢轴的位置。
        QSort(L, low, pivotloc-1); // 对基准元素左边的子序列进行快速排序,[low,pivotloc-1]
        QSort(L, pivotloc+1, high); // 对基准元素右边的子序列进行快速排序,[pivotloc+1,high]
    }
}
void QuickSort(SqList &L){
    // 对顺序表L进行快速排序
    QSort(L,1,L.length); // 调用递归函数Qsort进行快速排序。初始值low=1, high=L.length
}



/*==============================================================
* 8.4 选择排序
- 基本思想：每次从待排序序列中选择最小（或最大）的元素，放在已排序序列的末尾，直到所有元素都排好序。
*==============================================================*/

/* -------------- 8.4.1 简单选择排序（Simple Selection Sort，直接选择排序）--------------- */

//【算法8.6】简单选择排序（Simple Selection Sort，直接选择排序）
// 参考视频：第14周08--第8章排序8--8.4选择排序1--简单选择排序 https://www.bilibili.com/video/BV1nJ411V7bd?vd_source=b53bd15b89ae068fd295b2d36a386a97&spm_id_from=333.788.player.switch&p=166
// 参考课本：p246-p247
// 时间复杂度：O(n^2) （最好，最坏，平均都一样）
// 空间复杂度：O(1)。
// 基本思路：每次从待排序序列中选择最小（或最大）的元素，放在已排序序列的末尾，直到所有元素都排好序。
// 排序稳定性：不稳定。（但可以通过改进成稳定的选择排序）
// 性能对于顺序、无序、逆序的区别：顺序最好，O(n)；无序次之，O(n^2)；逆序最差，O(n^2)。 
// 存储结构：可以用顺序存储结构，也可以用链式存储结构。
// 适用情况：因为移动记录次数较少，所以当每个记录占用空间较多的时候，比直接插入排序要好。

void SelectSort(SqList &L){
    // 对顺序表L进行简单选择排序
    int i,j,k; // i是当前元素，j是前一个元素，k是最小元素的下标
    for(i=1; i<L.length; ++i){ // 从第1个元素到倒数第2个元素（因为到最后，最后一个元素已经排好序了），依次选择最小元素
        k = i; // 假设第i个元素是最小元素
        for(j=i+1; j<=L.length; ++j){ // 从第i+1个元素开始到最后一个元素，依次比较
            if(L.r[j].key < L.r[k].key) k = j; // 如果找到更小的元素，则更新最小元素的下标。k指向此次排序中关键字最小的记录
        }
        if(k != i) swap(L.r[i], L.r[k]); // 如果最小元素k不是第i个元素，则交换i和k的位置。否则不需要交换。
    }
}

/* -------------- 8.4.3 堆排序（Heap Sort）--------------- */

// 【算法8.7】筛选法调整堆
// 参考视频：第14周10--第8章排序10--8.4选择排序3--堆排序2--堆调整 https://www.bilibili.com/video/BV1nJ411V7bd?vd_source=b53bd15b89ae068fd295b2d36a386a97&spm_id_from=333.788.player.switch&p=168
// 参考课本：p251
// 思路：在交换了r[s]和r[m+1]之后，r[s+1]~r[m]已经是堆（大根堆），需要将r[s]~r[m]调整为堆（大根堆），像筛子一样，从上到下筛选，
//      让较大的元素往上走，较小的元素往下走。

void HeapAdjust(SqList &L, int s, int m){
    // 假设r[s+1]~r[m]已经是堆（大根堆），将r[s]~r[m]调整为堆（大根堆）
    // 注意：swap(L.r[s], L.r[m+1]) 是在主函数中对HeapAdjust函数的前置操作。
    RedType rc = L.r[s]; // 将当前节点保存到临时变量rc中。rc=record
    int j;
    for(j=2*s; j<=m; j*=2){ // 沿着key较大的孩子节点向下查找，直到叶子节点为止。
        if(j < m && L.r[j].key < L.r[j+1].key) ++j; // 如果右孩子存在且大于左孩子，则将j指向右孩子,否则指向左孩子
        if(rc.key >= L.r[j].key) break; // 如果当前节点rc大于等于子节点，则不需要调整，直接退出循环
        L.r[s] = L.r[j]; // 如果当前节点rc小于子节点，则将子节点的值赋值给当前节点
        s = j; // 更新当前节点s为子节点j，相当于s永远是j的双亲节点
    }
    L.r[s] = rc; // 将rc的值赋值给当前节点s，相当于将rc插入到正确的位置
}


// 【算法8.8】建初堆（大根堆）
// 参考视频：第14周11--第8章排序11--8.4选择排序4--堆排序3--建初堆 https://www.bilibili.com/video/BV1nJ411V7bd?vd_source=b53bd15b89ae068fd295b2d36a386a97&spm_id_from=333.788.player.switch&p=169
// 参考课本：p251-p252
// 思路：本质上是反复调用HeapAdjust函数的过程，从最后一个非叶子节点(n/2)开始，依次向上调整，直到根节点。叶子结点本身不需要调整。
void CreatHeap(SqList &L){
    // 把无序徐磊L.r[1]~L.r[length]调整为大根堆
    int i, n = L.length; // n是线性表的长度
    for(i=n/2; i>0; --i){ // 从最后一个非叶子节点开始，依次向上调整.这里的i是从n/2开始的，因为n/2是最后一个非叶子节点。
        HeapAdjust(L, i, n); // 调整为大根堆
    }
}

// 【算法8.9】堆排序（Heap Sort）
// 参考视频：第14周12--第8章排序12--8.4选择排序5--堆排序4--堆排序算法及分析 https://www.bilibili.com/video/BV1nJ411V7bd?vd_source=b53bd15b89ae068fd295b2d36a386a97&spm_id_from=333.788.player.switch&p=170
// 参考课本：p252
// 思路：先建初堆，然后将堆顶元素（最大元素）与最后一个元素交换，然后将剩下的元素重新调整为堆，直到所有元素都排好序。
// 时间复杂度：O(nlogn)（最好，最坏，平均都一样）
// 空间复杂度：O(1)。
// 排序稳定性：不稳定。
// 性能对于顺序、无序、逆序的区别：没有区别。
// 存储结构：顺序和链式存储结构都可以。
// 适用情况：n较大时较为高效。最坏情况下也是O(nlogn)，相比快速排序的O(n^2)还要好。

void HeapSort(SqList &L){
    // 对顺序表L进行堆排序
    int i, n = L.length; // n是线性表的长度
    CreatHeap(L); // 建初堆
    for(i=n; i>1; --i){ // 从最后一个元素开始，依次向前调整,直到第2个元素为止。注意这里是从n开始的，因为n是最后一个元素。
        swap(L.r[1], L.r[i]); // 交换堆顶元素1和 未经排序的子序列L.r[1]~L.r[i]的最后一个元素i
        HeapAdjust(L, 1, i-1); // 将L.r[1]~L.r[i-1]调整为大根堆。
    }
}
