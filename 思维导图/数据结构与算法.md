# 数据结构与算法

## Ch1_数据结构的基本概念
### 基本概念和术语
- 数据、数据元素、数据项、数对象
  - 数据(Data)：是指客观事物的符号化表示。
  - 数据元素(Data Element)：是数据的基本单位。比如说 一名学生的记录。
  - 数据项(Data Item)：是组成数据元素的最小单位。比如说 一名学生记录中的姓名、学号、性别都分别是1个数据项
  - 数据对象(Data Object)：是具有相同性质的数据元素的集合。比如说，所有学生的记录就是一个数据对象
- 什么是数据结构
  - 是指相互之间存在一种或多种特定关系的数据元素的集合
  - 或者说，数据结构是带结构的数据元素的集合
- **数据结构的两种层次**
  - **逻辑结构**：
    描述数据元素之间的逻辑关系；
    与数据的存储无关，独立于计算机；
    是从具体问题抽象出来的数学模型；
    - 1.线性结构
    （一对一）
      - 定义：有且仅有一个开始和一个终端结点，并且所有结点都最多只有一个直接前趋和一个直接后继
      - 分类
        - 一般线性表：线性表
        - 特殊线性表：栈、队列、串
        - 线性表的推广：广义表，数组
    - 2.非线性结构
      - 定义：一个结点可能有多个直接前趋和直接后继
      - 分类：
        - 树：一对多
        - 图：多对多
        - 集合：无关系
  - **存储结构（物理结构）**
    数据元素及其关系在计算机存储器中的结构（存储方式）
    - 1.顺序存储结构
      - 定义：数据元素在存储器中占用一段连续的存储单元
      - 优点：随机查找快，存储密度高
      - 缺点：插入删除需移动大量元素
    - 2.链式存储结构
      - 定义：数据元素在存储器中不一定是连续的，数据元素之间通过指针连接
      - 优点：插入删除方便，不需移动元素
      - 缺点：存储密度低，只能顺序查找
- 数据类型和抽象数据类型
  - 数据类型：是一个值的集合和定义在该值上的一组操作。比如int、char、float等
  - 抽象数据类型（ADT）：是由用户定义的数学模型，以及定义在该模型上的一组操作的总称。
    - 1. 数据对象：数据元素的集合
    - 2. 数据关系：数据元素之间的逻辑关系
    - 3. 基本操作：对数据对象进行操作的方法和步骤
- 概念小结：
  - ![数据结构概念小结（相互关系）](image.png)

### 算法和算法分析
- 算法的定义：对特定问题求解方法和步骤的一种描述，它是指令的有限序列。对解决问题的方法的描述
- 算法的描述方法
  - 1. 自然语言：英语、中文
  - 2. 流程图：传统流程图、NS流程图
  - 3. 伪代码：类C语言
  - 4. 程序代码：C语言，C++语言程序
- 算法的特性
  - 1. 有穷性：一个算法总是在执行有穷步骤后结束
  - 2. 确定性：算法中的每一条指令必须有确切的含义，没有二义性
  - 3. 可行性： 算法是可执行的
  - 4. 输入：一个算法有0个或者多个输入
  - 5. 输出：输出待求结果
- 算法设计的要求
  - 1. 正确性：
        - 没有语法错误
        - 对于精心选择的，苛刻的刁难的数据也能输出正确的结果
        - 程序对于一切合法的输入数据都能得到正确的输出结果
  - 2. 可读性
  - 3. 健壮性
        - 指当输入非法数据的时候，算法能够恰当的做出反应或进行相应处理，而不是输出莫名其妙的结果
        - 处理出错的方法，不应是中断程序的执行，而应是返回一个表示错误或者错误性质的值，以便在更高抽象层次上进行处理
  - 4. **高效性**：
      要求花费尽量少的时间和尽量低的存储需求
        - **时间效率**：
          指的是算法所耗费的时间
            - 1. 事后统计：将算法实现运行，测算其时间和空间的开销
              - 缺点：1. 将算法转换为实际能够运行的程序需要花费大量的时间2. 所得到的测试结果依赖于计算的软硬件等环境因素因此——不常用
            - 2. **事前分析**：对算法所耗时间和空间资源的一种估计。
              算法运行时间 =一个简单操作所需的时间（如赋值、移动、比较）*简单操作次数简单来说，
              就是算法中每条语句执行时间之和更进一步，将单条语句的执行之间设定为单位执行时间，
              不考虑硬件和语言特性则算法的耗费时间定义为该算法中每条语句的频度之和
                  - 王卓老师视频截图
                  - 为了便于比较不同算法的时间效率，简化我们分析算法的时间耗度，我们一般仅比较他们的数量级
                  - **时间复杂度的概念**：
                  若有某个辅助函数f（n），使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于0的常数，
                  则称f(n)是T(n)的同数量级函数。
                  记作T(n)=O(f(n))，称O(f(n))为算法的渐进时间复杂度（O是数量级的符号），简称时间复杂度。
                    - 对于复杂的算法，我们可以将算法分成容易估算的几个部分，
                      然后利用加法规则和乘法规则计算算法总的时间复杂度
                      - 1. 加法规则 O(f(n))=O(f1+f2)
                      - 2. 乘法规则 O(f(n))=O(f1xf2)
        - 空间效率：指的是算法执行过程中所耗费的存储空间。涉及空间复杂度。
          - 注意：O(1)表示算法原地工作。

## Ch2_线性表
### 线性表的定义：零个或多个元素的有限序列
- 线性表只有一个表头和一个表尾
- 线性表中每一个元素最多只有一个前趋和一个后继
### 存储结构方式
- 1.顺序存储——**顺序表(Sequential List)**:
必须是占用一片连续的存储空间。中间有空出来的地址，都不能叫做线性表的顺序存储。
利用数据元素的存储位置表示线性表中相邻元素的前后关系；顺序存储的线性表其逻辑关系和存储关系是一致的。
  - 基本操作：
    - 1. 顺序线性表初始化算法实现
    - 2. 顺序线性表的取值：随机存取（时间复杂度O(1)）
    - 2. 顺序线性表清空、销毁算法实现
    - 3. 顺序线性表查找算法实现：（时间复杂度O(n)）
    - 4. 顺序线性表插入、删除算法实现（时间复杂度为O(n)）
  - 存储位置计算公式：
    - LOC(a_i) = LOC(a_1) + (i-1) * l
    - l为数据元素的存储长度，比如说int类型的长度为4字节，char类型的长度为1字节。
  - 平均查找长度公式：
    - ASL(Average Search Length) = ∑i=1~n (P(i) * C(i))
    - P(i)为查找元素的概率，C(i)为查找元素的比较次数
- 2.链式存储——**链表(Linked List)**:
  由一个个结点相互链接形成的数据存储结构；每一个结点由数据域和指针域组成；
  数据域负责存储元素的数值数据；指针域负责存储直接后继（以及前趋）结点的存储位置；
  - 分类：
    - 1.单链表（线性链表）
      - 每个结点只有一个数据域和一个指针域
    - 2.双链表（Double Linked List）
      - 每个结点有一个数据域和两个指针域
    - 3.循环链表（Circular Linked List）
      - 首尾相接的链表成为循环链表
    - 4.双向循环链表
      - 双向循环链表是双链表和循环链表的结合
  - 术语：
    - 头指针：一般是L
    - 头结点
    - 首元结点： 第一个结点（头结点之后的第一个结点）。一般是L->next
    - 尾指针：非循环链表的尾指针->next=NULL；循环链表的尾指针->next=L
    - 尾结点
  - 单链表的基本操作：
    - 1.链式线性表初始化算法实现
    - 2.链式线性表的取值：顺序存取（时间复杂度O(n)），
    - 2.链式线性表清空、销毁算法实现
    - 3.链式线性表查找算法实现（时间复杂度O(n)）
    - 4.链式线性表插入算法（时间复杂度O(n)）
      - 头插法
      - 尾插法
    - 5.链式线性表删除算法实现（时间复杂度为O(n)）
  - 比较单链表、双向链表和循环链表：
    - ![比较单链表、双向链表和循环链表](image-1.png)
- 比较顺序表和链表：
  - ![比较顺序表和链表](image-2.png)
### 案例分析
- 一元多项式的运算：适合顺序表
- 稀疏多项式的运算：适合链表
- 图书馆的图书管理：
  - 如果图书馆的图书数量较多且需要频繁的插入和删除操作，使用链表；
  - 反之，如果图书馆的图书数量较少且需要频繁的查找操作，使用顺序表。
  
## Ch3_栈和队列
### 栈和队列是一种特殊的操作受限的线性表。
- 栈只能从表尾插入元素，删除元素只能删除最后一个元素，秉持着先进后出的原则（LIFO）。
- 队列只能从表尾插入元素，删除元素只能删除第一个元素，秉持着先进先出的原则（FIFO）。
- 从数据结构角度，栈和队列都是线性表的特殊形式；
- 从数据类型角度，栈和队列 与 线性表是不同的ADT。
### **栈(LIFO)**
- 1.顺序结构栈
  - 常用，因为比较简单，清空和销毁都比较方便
- 2.链式结构栈
- 3.栈和**递归**
  - 我们熟知的递归函数就是使用了栈的一种方法。
    每一次函数的调用，变量和返回地址都会被保存在栈里最先调用的，最后拿出来。
- 采用**递归**算法解决问题的情况：
  - 1.定义是递归的——采用分治法进行递归求解的三个条件：
    - 1. 能将一个问题转变成一个新问题，解法相同或者类似，处理对象更小且变化有规律
    - 2. 可通过上述转化使问题简化
    - 3. 必须有一个明确的递归出口，或称递归的边界
    - 比如：斐波那契数列（时间复杂度O(2^n)）
  - 2.数据结构是递归的：
    - 比如：链表LNode是指针套指针的结构体
  - 3.问题的解法是递归的（用递归比迭代更简单）：
    - 比如：汉诺塔问题（时间复杂度O(2^n)）
- 递归的优缺点
  - 优点： 代码简洁，易读性高
  - 缺点： 时间复杂度高，空间复杂度高
  - 解决方法：转为非递归算法，通过保存好的状态来加速（比如全局变量）
### **队列(FIFO)**
- 1.顺序队列
  - 常用循环顺序队列（涉及到对maxqsize取模）
  - 循环顺序队列如何判断空队和满队？
    - 1. 设置一个标志flag
    - 2. 增加了一个变量对元素个数计数
    - 3. 教材使用方法：**少使用一个空间，让空队的判断条件是front==rear满队的判断条件为front == rear_next**
         - ![循环队列：少使用一个空间](image-3.png)
- 2.链式队列
  - 链式队列其实就是一种简化版的链表
    - 与链表的相同的地方
      - 初始化、添加、删除元素用的是同一种逻辑
    - 与链表不同的地方
      - 插入元素只能在表尾插，删除元素只能删除表头的元素
      - 定义的方式有些许不一样，导致后面函数的访问就不一样
### 案例分析：
- 1.栈的应用
  - 数制转换
    - 进制转换：十进制转二进制、十六进制
    - 进制转换：二进制转十进制、十六进制
  - 1.表达式求值
    - 中缀表达式转后缀表达式
    - 后缀表达式求值
  - 2.括号匹配问题
    - 用栈来存储左括号，遇到右括号就出栈一个左括号
    - 如果栈空了，说明没有匹配的左括号
    - 如果栈不空，说明有多余的左括号
- 2.队列的应用
  - 1.舞伴排队问题
  - 2.打印机排队问题
### 补充：卡特兰数递推式
- 定义：表示n个数的出栈序列的个数,也就是n个数出栈有多少种可能
- 公式：$h(n) = \sum_{i=0}^{n-1} h(i) * h(n-i-1) = \frac{C(2n,n)}{n+1}$
- 例子：h(3) = 5, 意味着3个数的出栈序列有5种——123，132，213，231，321

## Ch4_串、数组、广义表
### 1.串：字符串的简称
- 串的一些术语
  - 1. 子串：串中任意个**连续**字符组成的子序列成为该串的子串
  - 2. 主串：包含子串的串相应地称为主串
  - 3. 字符位置：字符在序列中的序号为该字符在串中的位置
  - 4. 子串位置：子串第一个字符在主串中的位置
  - 5. 空格串：由一个或多个空格组成的串，与空串是不一样的
  - 6. 串相等：当且仅当两个串的长度一样，且对应的字符都一一相等才能叫做串相等
- 串的存储结构
  - 1. 顺序存储：简单，灵活。常用
  - 2. 链式存储：插入和删除比较方便，但是存储效率只有20%，太低了。
  （之所以是20%,是因为每个结点都要存储一个指针，指针的长度是4字节，而数据域为char类型，长度为1字节，所以存储密度= 1/(1+4) = 20%）
- 串的模式匹配算法：
  - 1.暴力匹配算法(Brute Force,BF算法)：
    - 时间复杂度：O(n*m)，其中n为主串长度，m为子串长度。不过实际执行时近似于O(n+m)
  - 2.KMP算法：
    - **核心优化点（相比于BF算法）：当匹配失败时，主串指针不回退，模式串根据 next或者nextval 数组跳转到合适位置继续匹配。**
    - 主匹配过程
      - 两个指针 `i`、`j` 遍历主串 `s` 和模式串 `p`。
      - 若匹配成功：`s[i] == p[j]`，则 `i++` 和 `j++`。
      - 若失配：`j = next[j]`，即模式串跳回 next 指定位置。本质上是回退到**次最长**相等前后缀的位置。
      - 如果next改用nextval数组，失配时 `j = nextval[j]`。本质上是回退到**次最长**相等前后缀的n次方位置，直到p[j]!=p[nextval[j]]。
      - 直到 `j == len(p)`，说明成功匹配，返回 `i - j` 为匹配起始位置。
    - 原始的KMP算法：用到next数组.
    - 改进的KMP算法：用到next数组和nextval数组
    - 时间复杂度：O(n+m)
### 2.数组
- 1.二维数组的逻辑结构
  - 1. 可以看做是非线性结构：一个在二维数组的元素，可能不止有一个前趋和一个后继，因此不是一个线性结构
  - 2. 也可以看作是线性的。因为其实没有二维数组的概念，二维数组本质上是数组的数组，一维数组中每一个元素又是一维数组罢了
- 2.数组的顺序存储
  - 二维数组，行序为主序的 元素a_ij的存储位置公式：
      - LOC(i,j) = LOC(0,0) + (n*i+j)*L
      其中L为数据元素的存储长度（比如int类型的长度为4字节，char类型的长度为1字节），n为矩阵的列数，LOC(0,0)为a_00的存储位置。
      - 公式变形：LOC(i,j) = LOC(s,t) + (n*(i-s)+(j-t))*L
        - 假设矩阵不是A[0,...,m-1,0,...n-1] 而是A[s,...,m-1,t,...n-1]，那么就可以用这个公式来计算
  - n维数组的存储位置公式：
    - LOC(j1,j2,...,jn) = LOC(0,0,...,0) + (b2*···*bn*j1+b3*···*bn-1*j2+...+bn*jn-1+jn) *L
      - 其中b1,b2,...,bn为各维的长度，L为数据元素的存储长度 
- 3.二维数组的压缩存储方法
  - 1.对称矩阵
    - 压缩存储方法：假设一维数组sa[n(n+1)/2]来表示n阶对称矩阵A的存储结构，那么sa[k]与a_ij的关系为：
        - $$
          k = \begin{cases}
          \frac{i(i - 1)}{2} + j - 1, & i \geq j \\
          \frac{j(j - 1)}{2} + i - 1, & i < j
          \end{cases}
          $$
  - 2.三角矩阵
    - 压缩存储方法：
      - 1.上三角矩阵：只存储上三角的元素。
        假设一维数组sa[n(n+1)/2+1]来表示n阶上三角矩阵A的存储结构，那么sa[k]与a_ij的关系为：
        - $$
          k = \begin{cases}
          \frac{(i-1)(2n- i+2)}{2} + j - i, & i \leq j \\
          \frac{n(n+1)}{2} , & i > j
          \end{cases}
          $$
      - 2.下三角矩阵：只存储下三角的元素。同理：
        - $$
          k = \begin{cases}
          \frac{(i(i-1))}{2} + j - 1, & i \geq j \\
          \frac{n(n+1)}{2} , & i < j
          \end{cases}
          $$
  - 3.稀疏矩阵（矩阵中超过95%的元素都是0）
    - 压缩存储方式：
      - 三元组：用一个三元组表示稀疏矩阵中的非零元素三元组的前两个元素是表示元素的坐标，第三个元素是值本身, 如(i,j,a_ij);
      - 十字链表：节省空间，但是丧失随机存储功能
  - 4.带状矩阵（对角矩阵）
    - 压缩存储方法：
      - 1.每一条带（对角线）存一行
      - 2.带状矩阵每一行非零的存一行（最前面几行和最后面几行要补0）
### 3.广义表
- 广义表是线性表的推广线性表中的元素是单一的，而广义表中的元素可以是一种普通的数据类型也可以是广义表本身，有一种递归的潜质
  - ![广义表表头和表尾的几个例子](image-4.png)
- 广义表的几种定义
  - 广义表的表头是第一个元素，表尾是除开第一个元素的剩余元素集合广义表的递归有些类似于链表
- 广义表的一些术语
  - 1. 广义表的长度：最外层括号所包含的元素个数
  - 2. 广义表的深度：把广义表展开，括号对的重数。空表是深度为1，原子深度为0
  - ![广义表多层次结构](image-5.png)
  - 4. 一个非空广义表的表头可以是一个原子，也可以是一个广义表。但是广义表的表尾一定是一个表尾
  - 5.广义表的存储结构：链式存储结构
    - 1.头尾链表：表结点（tag，hp，tp）+原子结点（tag，atom）
    - 2.扩展性链表：表结点+原子结点（多了个tp域）

## Ch5_树和二叉树
### 1.树的定义
- 1.树的定义
  - n（n&gt;=0）个结点的有限集
    - 1. n=0时称为空树
    - 2. n&gt;=1时有且仅有一个结点称为树的根（root）其余结点可分为m(m&gt;=0)个互不相交的有限集合，T1,T2...其中每一个有限集合又可以看作是一个树，称为子树（sub-tree）
  - 常见的，我们写文章标题的分类，就是树的结构
- 2.树的术语
  - 1. 根结点：非空树表中，没有直接前趋的结点就是根节点
  - 2. 结点的度：结点所包含的子树的个数
  - 3. 树的度：树内各结点的度的最大值
  - 4. 叶子结点：度为0的结点称为叶子结点
  - 5. 非终端结点：度不为0的结点称为非终端结点或分支结点。除了根节点之外的非终端结点也叫内部结点
  - 6. 双亲和孩子
  - 7. 兄弟
  - 8. 祖先
  - 9. 子孙
  - 10. 结点的层次：从根结点到该结点所经过的边数称为该结点的层次
  - 11. 堂兄弟：双亲在同一层的结点称为堂兄弟
  - 12. 树的深度：树种结点层次的最大数，有时也叫树的高度
  - 13. 有序树和无序树：各个子树是否从左到右有序
  - 14. 森林：m（m&gt;=0）互不相交的树的集合。注意：树是特殊的森林，森林不一定是树。
  - ![树的术语介绍](image-6.png)
- 3.树和线性表之间的区别：
  - 1. 线性表的表头元素无前趋树的根节点无双亲
  - 2. 线性表的表尾元素无后继树的叶子无孩子
  - 3. 线性表中的元素只有一个前趋和一个后继：一对一的关系树中的结点是有一个双亲和多个孩子：一对多的关系
### 2.二叉树（Binary Tree）
- 二叉树的存在意义：普通的树因为太复杂了，用计算机实现的话非常麻烦因此我们常用二叉树来使用树
- 1.二叉树的定义：
  - 由一个根节点和两个互不相交的左子树和右子树构成的集合
    - 1. 二叉树的结点最多只有两个度，也即只有两个孩子
    - 2. 二叉树的子树是有左右之分的
    - 严格来说，二叉树不是树的特殊情况这是因为二叉树对子树的左右次序进行了严格的要求，即使只有一个子树，也要说明是左还是右|这是二叉树和树之间最大的差别
- 2.二叉树的性质
  - 1.二叉树的第i层中最多有$2^{(i-1)}$个结点($i \geq 1$)，最少也得有1个结点
  - 2.深度为k的二叉树的结点总数最多为$2^k - 1$($k \geq 1$)，最少结点数为k
  - 3.在一个二叉树中，设叶子数（没有分支）的个数为 `n0`，度为2（有两个分支）的个数为 `n2`，则有 `n0 = n2 + 1`。
    - **证明**：  
    设二叉树的边线总数为 `B`，则：
     `B = n - 1`(根结点没有入的边) 和 `B = 2 * n2 + n1`  
    由 `n = n0 + n1 + n2`，代入得：  
    `n0 + n1 + n2 - 1 = 2 * n2 + n1`  
    化简得：  `n0 = n2 + 1`，也就是说叶子结点的个数等于度为2的结点个数加1
  - 补充知识点
    - 1.满二叉树：
      深度为k，结点总数为$2^k-1$（max）
      - 满二叉树的叶子数是同深度最多的，$2^{(k-1)}$
      - 满二叉树在同样深度的二叉树中，结点数是最多的
      - 满二叉树的形态种类也符合卡特兰数，也就是$h(n) = \frac{C(2n,n)}{(n+1)}$种
    - 2.完全二叉树：
      从满二叉树的最后一个结点（二叉树顺序：从上到下，从左到右），依次连续的去掉结点的二叉树，才能叫完全二叉树
      - 完全二叉树和满二叉树的编号是一一对应的
      - 完全二叉树的叶子结点只能分布在第i层和第i-1层（也就是最后一层和倒数第二层）
      - 完全二叉树的任意结点，如果右分支的子孙最大层位l，则该结点的左分支的子孙最大层位为l或者l+1
      - 3.具有n个结点的二叉树，有n+1个空指针域
      - 4.具有n个结点的完全二叉树的深度k为：$k = \lceil \log_2 n \rceil$
      - 5.具有n个结点的完全二叉树，其结点i(按层序以及从左往右编号)有如下性质
        - 1. $i= 1$：该结点是根节点
        - 2. $i>1$: i的双亲结点是 $\lfloor \frac{i}{2} \rfloor$
        - 3. $2*i > n$:那么该结点为叶子结点
        - 4. $2*i +1>n$:那么该节点没有右孩子
        - 5. 同理可得，结点i的左右孩子分别是$2*i$和$2*i+1$（若存在，也就是$2*i \leq n$和$2*i+1 \leq n$）
- 3.二叉树的存储方式
  - 1. 顺序存储方式
    - 不常用，缺点如下：
      1. 顺序结构不能改变长度，插入和删除很慢
      2. 顺序结构表示非完全二叉树的时候，非常浪费空间，最坏情况下是单支树，存储密度低，仅为$\frac{k}{2^k-1}$
  - 2. 链式存储方式
    - 性质：有n个结点的二叉链表，其结点的链域为空（空链域）的个数为n+1
      - 证明：n个结点有2n个链域，n个结点有n-1个双亲结点（排除了根结点），所以有2n-(n-1)=n+1个空链域。
- 4.二叉树的遍历方式
  - 遍历二叉树时，我们选定一种遍历方式，比如说LDR中序遍历在遍历时，对每一个结点（子树）都采用该遍历方式
    ![先中后序遍历](image-13.png)
  - 已知遍历结果，能否反推二叉树的形状？（中序必须知道）
    - 1. 已知先序和中序 可以反推
      - 先序的首元素一定是根结点那么，在中序中找到根结点，位于根结点之前的都是根结点的左子树，之后的都是右子树的再反复根据先序和中序确定每一个元素的位置
    - 2. 已知中序和后序 可以反推
      - 后序（LRD）的尾元素一定是根结点那么，在中序中找到根结点，位于根结点之前的都是根结点的左子树，之后的都是右子树的再反复根据后序和中序确定每一个元素的位置
- 5.二叉树的操作
  - 1. 二叉树的遍历
    - 1. 先序遍历DLR
    - 2. 中序遍历LDR
    - 3. 后序遍历LRD
    - 4. 中序遍历的非递归算法——使用**栈**保存结点信息
    - 5.二叉树的层次遍历算法
      - BFS广度优先算法
      - 算法设计思路：    
        - 1.将根结点入队    
        - 2.队列不为空时循环，从**队列**中出列一个元素，访问它，并作以下步骤：
          - 2.1 如果该元素的左孩子不为空，让该元素的左孩子入队        
          - 2.2 如果该元素的右孩子不为空，让该元素的右孩子入队
  - 2. 二叉树的创建
    - 1. 选定一个遍历方式。常用先序遍历DLR
    - 2. 使用递归函数，创建一个二叉树
    - 3. 设定一个输入的特定字符，用于判定当前创建的结点没有左右孩子
  - 3.二叉树的复制
    - 同二叉树的创建操作基本一致
  - 4.求二叉树的深度
    - 算法非常巧妙，还是递归函数的方式，只不过在函数内部有两个变量，用于保存当前的深度值，通过比较输出双亲的左或右孩子的深度值
  - 5. 求二叉树的结点数
  - 6. 求二叉树的叶子数
- 6.线索二叉树
  - 1.线索二叉树的定义
    - 利用之前的性质：
      - 具有n个结点的二叉树有n+1个空指针域
      - 线索二叉树就是把这些空指针域利用起来，指向该结点的前驱和后继结点
    - 如果一个二叉树的的结点的左指针域为空，那么我们将左指针指向这个结点的前驱如果结点的右指针为空，那么将右指针指向这个结点的后继这里的前驱和后继指的是输出序列中结点的前后关系
  - 2.线索二叉树的构造方法
    - 新增2个标志域，分别表示该结点的左指针和右指针是否为空：LTag和RTag。
      - 若左子树存在，则LTag=0，lchild指向左子树的根结点；若左子树不存在，则LTag=1，lchild指向该结点的前驱结点。
      - 若右子树存在，则RTag=0，rchild指向右子树的根结点；若右子树不存在，则RTag=1，rchild指向该结点的后继结点。
      - 用标志域而不是链域，是因为标志域的存储密度更高，节省空间——每个标志域只要1个bit存01哑变量（或者1个int也就是4个Bytes），而链域一般需要8个Bytes存地址
    - 新增1个头结点，lchild指向根结点，rchild指向遍历访问顺序的最后一个结点
    - 遍历访问的第1个结点的lchild指向头结点，最后一个结点的rchild指向头结点（相当于最后一个结点与头结点互相用rchild连接对方）
  - 3.遍历线索二叉树
    - 其中中序最简单。查找方法如下：
      - 1.查找p的前驱
        - 1.1 如果p的LTag=0，p的前驱就是p的左孩子
        - 1.2 如果p的LTag=1，p的前驱就是p的lchild遍历访问的最后一个结点（左子树中最右下的结点）
      - 2.查找p的后继
        - 2.1 如果p的RTag=0，p的后继就是p的右孩子
        - 2.2 如果p的RTag=1，p的后继就是p的rchild遍历访问的第一个结点（右子树中最左下的结点）
    - 先序线索二叉树的查找
    - 后序线索二叉树的查找

### 3.树和森林
- 1.树的存储方式
  - 1.双亲表示法
    - 用一个数组存放一棵树，数组的元素是结构体，结构体的内容是树结点的内容，以及当前结点的双亲在数组中的下标
      ![双亲表示法](image-7.png)
  - 2.孩子链表法
    - 把每一层的每一个结点的孩子们看作是一个链表，然后用数组存储树的每一个结点（从上到下，从左到右）每个结点的孩子链表的数据域内容是孩子结点在数组中的位置
      ![孩子链表1](image-8.png)
    - 这种存储方式，比较容易找到一个结点的孩子，但是不容易找到结点的双亲，那怎么样可以又快速找到双亲，又找孩子呢？答案就是将孩子链表和双亲表示法结合起来，得到一个双亲孩子链表表示方法
      ![孩子链表2](image-9.png)
  - 3.**孩子兄弟表示法（又名二叉树表示法，或二叉链表表示法**（常用）
    - 同二叉树的定义方式相似，定义一个数据域，两个指针域。左指针指向当前结点的孩子，右指针指向当前结点的兄弟结点，没有就为空。
      ![孩子兄弟表示法](image-10.png)
- 2.树和二叉树的转换方式
  - 树转换成二叉树
    - 借助与树的孩子兄弟链表表示法，我们将树转换为二叉树，几个字概括其转换方式：兄弟相连留长子
    ![树转换成二叉树](image-11.png)
  - 二叉树转换成树
    - 口诀：左孩右右连双亲，去掉原来右孩线
    - ![二叉树转换成树](image-12.png)
- 3.树的遍历方式
  - 1. 先根（序）遍历：先访问树的根节点，再访问子树
  - 2. 后根（序）遍历：先访问树的子树，最后访问根结点
  - 3. 层次遍历
- 4.森林的遍历方式
  - 1.先序遍历（类似于树的先根遍历）
    - 把森林拆分成一个个树，对树进行先根遍历
  - 2.中序遍历（类似于树的后根遍历）
    - 把森林拆分成一个个树，对树进行后根遍历

### 4.哈夫曼树
- 1.最优哈夫曼树的概念
  - 1.先补充点知识
    - 1. 路径：树的结点与结点之间的连线就是路径
    - 2. 树的路径长度：从树的根节点到树的每个结点的路径长度之和
    - 3.权重：叶子结点的权重系数。可以分为结点权和边权
      - 1. 结点权：结点的权重系数
      - 2. 边权：边的权重系数
    - 4. 树的带权路径长度之和 **(WPL,Weighted Path Length)**：从根节点到叶子结点的路径之和再乘以对应的叶子结点的权重系数
  - 2. 哈夫曼树：带权路径长度之和（WPL）最小的树，也即最优树
  - 3. 哈夫曼树不唯一，同一带权路径长度之和可以有多种二叉树形式
  - 4. 满二叉树不一定是哈夫曼树
  - 5. 哈夫曼树中权重越大的结点离根结点越近
- 2.哈夫曼树的构造
  - 1.构造思路：
    - 0. 口诀：(1)构造森林全是根，(2)选用两小造新树，(3)删除两小树添新人，(4)重复(2)(3)剩单根
    - 1. 删除两小造新人：把权重结点设定为只有根结点的一颗颗树，把这些树组成一个森林从树里面找到权重最小的两棵树，组成一颗新树，新树的权重是两小树的和在森林中删除这两个小树，保留新的合成树。
    - 2. 重复以上过程，直到森林变成一棵树
  - 2.本质：贪心算法
- 3.哈夫曼编码
  - 定义：对于一颗具有n个叶子结点的哈夫曼树，若对树中的每个左分支标记为0，对每个右分支标记为1，则从根结点到每个叶子结点的路径上，所经过的分支所标记的0和1的序列，称为该叶子结点的哈夫曼编码
  - 构造思路
    - 1. 由结点的权重构造一颗哈夫曼树（调用哈夫曼树构造函数）
    - 2. 从哈夫曼树的根节点开始，左边的路径是0，右边的路径是1，每一个的叶子结点的哈夫曼编码就此产生
  - 目的：
    - 1. 用于数据压缩
    - 2. 用于数据加密
    - 3. 本质上是为了文本总体长度的最小化（也就是min WPL）
- 4.哈夫曼解码
  - 解码思路
    - 1. 要通过哈夫曼编码算法得到哈夫曼的编码HC
    - 2.有了字母对应的哈夫曼编码表，我们可以使用两种方式进行解码
      - 1. 不查表：用暗文的二进制码，代入到哈夫曼树中，根据哈夫曼编码的原则，从哈夫曼树的根节点开始向下，直到到达叶子结点，该叶子结点的就是对应的明文
      - 2. 查表：我们通过哈夫曼编码算法都已经得到一个明文-暗文的对照表了，那我们就可以使用BF或者KMP匹配算法在暗文中一点点的匹配对应的解码暗文，最终翻译整个暗文

## Ch6_图
### 1.图的定义和术语
- 1.G=（V,E）。
  V：顶点（数据元素）组成的有限非空集合。E：边的有限集合。
  n为顶点数，e为边数。
  - 1. 有向图，图的边是有方向的，顶点对<x,y> 是有序的，表示从x指向y的一条有向边，x是弧头，y是弧尾
  - 2. 无向图，图的边没有方向，顶点对(x,y)是无序的，表示x和y之间有一条无向边
  - 3.完全图：图的任意两个点都有边相连（相当于边数已经达到最大值）
    - 无向图边的条数：$n*(n-1)/2$（n为顶点数）
    - 有向图边的条数：$n*(n-1)$（n为顶点数）
  - 4.稀疏图和稠密图
    - 稀疏图：图的边数量很少
    - 稠密图：图的边数量很多
  - 5. 图的度：图的顶点相关联的边的数目无向图中，一个顶点有几条边就是度多少有向图中，分为出度和入度，出度和入度加起来是度。（TD = ID + OD,即 度=入度+出度）
    - n，e，TD的公式： $e = \frac{1}{2} \sum_{i=1}^{n} TD_i$，TD_i为第i个顶点的度
  - 6. 图的路径：接续（连续的）边构成的顶点序列
  - 7.连通图：在一个图中，任意两个顶点V,U都能找到连接他们的路径，那么这个图就是一个连通图，如果图是有向图的话，那称为强连通图
  - 8. 子图：有如下G1和G两个图，如果有V1属于V，E1属于E，那么可以说G1属于G，G1是G的子图
  - 9. 网：边/弧 带权的图。（之前的哈夫曼是带权的结点，这里是带权的边/弧）
  - 10. 邻接：两个顶点之间有边/弧相连。
  - 11. 路径和路径长度：路径是从一个顶点到另一个顶点的连续的序列，路径长度是路径上边/弧的数量
  - 12. 回路或环：第一个顶点和最后一个顶点是相同的路径称为回路或环。
  - 13. 简单路径、简单回路或简单环：路径上没有重复的顶点称为简单路径；除了第一个和最后一个顶点相同，其他的顶点都不重复出现的回路称为简单回路或简单环。（反例：走8字）
  - 14. 连通、连通图和连通分量：连通是指两个顶点之间有路径；在一个图中，如果任意两个顶点之间都存在路径相连，那么这个图就是连通图；连通分量是指图中极大连通子图。（极大连通子图是指加入任何一个顶点，都会使得该子图不连通）
    - ![连通图](image-14.png)
  - 15. 强连通图和强连通分量：在一个有向图G中，如果任意两个顶点之间都存在路径相连，那么这个有向图就是强连通图；有向图中的极大强连通子图称为强连通分量。（强与不强其实是无向图和有向图的区别）
    -![连通图与强连通图](image-15.png)
  - ![连通分量](image-16.png)
  - ![强连通分量](image-17.png)
  - 16. 连通图的生成树：一个极小连通子图，包含了图的所有顶点，但只有足以构成一棵树的n-1条边，这样的连通子图称为连通图的生成树。如果在一颗生成树添加一条边，必定会形成一个环。（极小连通子图是指在该子图中，去掉任何一条边，都会使得该子图不连通）
    - ![连通图的生成树](image-18.png)
  - 17. 有向树和生成森林：有一个顶点的入度为0，其他顶点的入度为1的有向图称为有向图树；有向图的生成森林是由若干个有向图树组成的，含有图中全部顶点，但只有足以构成若干颗不相交的有向树的弧。

### 2.图的存储方式
- 1.邻接矩阵表示法（Adjacency Matrix）
  - 用一个二维数组，数组大小等于图的顶点个数的方阵。两个顶点之间有邻接关系，数组相应位置记为1，否则记为0。
  - 无向完全图的矩阵对角线为0，其余位置元素为1。无向图的邻接矩阵是一个对称矩阵。无向图的每一行或者每一列就代表对应元素的度
    ![邻接矩阵和无向图的邻接矩阵](image-19.png)
  - 在有向图中，邻接矩阵不是对称矩阵了每一行表示的是从这个顶点发出的边（出度），每一列表示的是这个顶点接收的边（入度），行的非0元素和+列的非0元素和=度
  - 网（有权图）的邻接矩阵，元素的值是边的权值，∞表示没有边相连（注意不是0）。
    ![有向图的邻接矩阵和网的邻接矩阵](image-20.png)
  - 优缺点：
    - 优点：
      - 简单、直观、便于理解，计算某个顶点的度十分的方便
      - 便于判断两个顶点v1和v2之间是否有边
    - 缺点：
      - 对图进行增加或者删除顶点的操作很麻烦，
      - 不便于统计边的数目，
      - 存储效率低，尤其是稀疏图，顶点多边少，很浪费计算机资源。创建图的算法时间复杂度高：O(n^2)。即使无向图用压缩存储的方式只存上/下三角矩阵，缩减到n*(n-1)/2，空间复杂度也为O(n^2)。
- 2.邻接表表示法（Adjacency List）
  - 类似于树的孩子链表表示法首先需要一个数组，数组的元素是顶点和指针域，指针域指向与顶点相连的边结点，在邻接表中每个顶点后面带的链表，就是与该顶点相连的边。相当于邻接矩阵的n行改成了n个单链表。
  ![邻接表（链式）](image-21.png)
  - 在无向图中，邻接表的空间复杂度为O(n+2*e)；在有向图中，邻接表的空间复杂度为O(n+e)。其中表示表示有向图的出度的叫邻接表表示有向图入度的叫逆邻接表。
  - 优缺点：
    - 优点：
      - 空间复杂度低，适合于稀疏图，
      - 便于图的增加和删除顶点
      - 在无向图中便于查看每个顶点的度（统计边的数目）
    - 缺点：
      - 不便于查看两个顶点v1和v2之间是否有边
      - 对于有向图，不便于统计每一个顶点的度（得到出度容易但入度难）。如果构造逆邻接表，也有类似的问题（得到入度容易但出度难）。
  ![针对邻接表的缺点的2种解决方法](image-22.png)
- 3.十字链表（Orthogonal List）表示法
  - 定义：是有向图的一种特殊的邻接表表示法，可以看成是将有向图的邻接表和逆邻接表结合起来的一种表示方法。
    ![十字链表（Orthogonal List）](image-23.png)
  - 解决了有向图在邻接表表示时，顶点度的统计不便问题——顺着顶点结点的firstin指针可以找到该顶点的所有入度边，顺着firstout指针可以找到该顶点的所有出度边。
  - 也可以看作是邻接矩阵的链式存储结构。
- 4.邻接多重表（Adjacency MultiList）表示法
  - 定义：是无向图的一种特殊的邻接表表示法
    ![邻接多重表（Adjacency MultiList）](image-24.png)
  - 解决了无向图在邻接表表示时，每一个边要被保存两次，会带来操作上的不便（例如删除边，要去找到重复的这两个边）

### 3.图的遍历方式
- 1.深度优先遍历算法（DFS,Depth First Search）
  - 定义：一种从图的某个顶点出发，沿着一条路径不断向前探索，直到无法继续为止，然后回溯到上一个顶点，继续探索其他路径的算法。
  ![深度优先遍历算法（DFS）](image-25.png)
  - 类似于树的先序遍历（DLR），是其推广。
  - 邻接矩阵
    - 时间复杂度：O(n^2)
    - 空间复杂度O(n)
  - 邻接表
    - 时间复杂度：O(n+e)
    - 空间复杂度O(n)
- 2.广度优先遍历算法 (BFS,Breadth First Search)
  - 定义：一种从图的某个顶点出发，先访问该顶点，然后访问与该顶点直接相连的所有顶点，再访问这些顶点直接相连的所有顶点，以此类推，直到所有顶点都被访问过为止的算法。
  - 类似于树的层次遍历，是其推广。（所以像层次遍历一样，使用队列来存储顶点）
  ![广度优先遍历算法（BFS）](image-26.png)
  - 邻接矩阵
    - 时间复杂度：O(n^2)
    - 空间复杂度O(n)
  - 邻接表
    - 时间复杂度：O(n+e)
    - 空间复杂度O(n)
- 3.图的遍历算法的应用：连通性问题，拓扑排序，关键路径等算法的基础。
- 4. 注意：常用visited数组来标记顶点是否被访问过，避免重复访问;以及会考虑回溯时恢复现场。

### 4.图的应用
- 最小生成树（Minimum Spanning Tree，MST，又称最小代价生成）
  - 定义：在一个连通网的所有生成树中，各边的代价之和最小的生成树称为最小代价生成树，简称最小生成树。
  - 主要针对**无向网**（连通图就是无向的）
  - 回顾生成树的性质：
    - 1.可以有多棵生成树
    - 2.生成树的边数是n-1（n为顶点数）
    - 3.生成树的结点数是n（也就是所有顶点都包含在内）
    - 4.使得结点互相连通但是不存在回路
  - 应用举例：
    - 交通问题：如何在n个城市之间修建道路，使得总的修建成本最低——有n(n-1)/2条边，从中选择n-1条边，使得所有城市互相连通，且总的修建成本最低。
  - MST性质（为多数算法利用）：
    - 内容：假设N=(V,E)是一个连通网，U是顶点集V的一个非空子集，若（u,v）是U的一个顶点和V-U的一个顶点之间的边，且(u,v)是U的所有边中权值（代价）最小的边，则必然存在一颗最小生成树包含这条边。
    - 证明方法：反证法
    - 本质：贪心算法（每次选择当前权值最小的边）
  - 具体算法：
    - 1.prim算法（加点法）
      - 该算法就像是一条蛇一样，每一次都从和中选择权重最小的一条边，连接成新的图
      ![Prim算法](image-27.png)
        - 算法时间复杂度O(n^2)
        - 适合稠密图
        - 本质上是每次增加点。
    - 2.Kruskal算法（加边法）
      - 该算法是把图的边按照权重大小排序，在保证不会连接成环的情况下，依次选择最小的边，当边数=n-1或者图已经连通了，这个算法就可以终止了
      ![Kruskal算法](image-28.png)
        - 算法时间复杂度O(eloge)
        - 适合稀疏图
        - 本质上是每次增加边。
- 最短路径
  - 主要针对**有向网**
  - 具体算法：
    - 1.dijkstra算法（迪克斯特拉算法）
      - 该算法是从一个顶点出发，找到到其他所有顶点的最短路径
      ![Dijkstra算法](image-29.png)
        - 算法时间复杂度O(n^2)
        - 如果通过dijkstra算法求每一对顶点之间的最短路径，那么时间复杂度是O(n^3)，与Floyd算法相同。
    - 2.Floyd算法（弗洛伊德算法）
      - 该算法是从所有顶点出发，找到到其他所有顶点的最短路径（每一对顶点之间的最短路径）
      ![Floyd算法](image-30.png)
        - 算法时间复杂度O(n^3)
- 有向无环图及其应用
  - 定义：有向无环图（Directed Acyclic Graph，DAG）是一个无环的有向图。
    ![DAG](image-31.png)
  - 应用：
    - **拓扑排序（Topological Sorting）**：
      - AOV-网（注意是图不是网，虽然名字带有网）
        - 定义：用顶点表示活动，边表示活动之间的先后关系的有向图称为顶点表示活动的网（Activity On Vertex，AOV）。
      - 定义：在有向无环图中，所有顶点的线性序列称为拓扑序列，拓扑排序就是将有向无环图的所有顶点排成一个线性序列，该序列满足：若在AOV网中存在一条从顶点u到顶点v的有向边，则在拓扑序列中顶点u排在顶点v之前。
      - 应用：检测AOV网中是否存在环，如果存在环，则无法进行拓扑排序；如果不存在环，则可以进行拓扑排序。
      - 过程：
        ![拓扑排序的方法](image-32.png)
        - 1.从AOV网中找出无前驱的顶点（入度为0），将其加入拓扑序列。
        - 2.在图中删除该顶点及其所有出边（以该顶点为尾的弧）
        - 3.重复步骤1和2，直到不存在无前驱（入度为0）的顶点为止。
        - 4.如果所有顶点都被加入拓扑序列（输出的顶点数=图的顶点数），则AOV网是有向无环图，输出的顶点序列是一个拓扑序列，否则AOV网中存在环。
      - 应用举例：
        - 课程表问题：给定一组课程和它们之间的先后关系，判断是否可以完成所有课程的学习，并输出一个可行的学习顺序。
    - **关键路径（Critical Path）**
      - AOE-网（有权，是网，相当于有向无环网）
        - 定义：用边表示活动，顶点表示活动之间的先后关系、权表示活动持续时间的有向图称为边表示活动的网（Activity On Edge，AOE）。
      - 定义：在AOE网中，一条路径各弧的权值之和称为该路径的带权路径长度（简称路径长度），AOE网中从源点（入度=0，只有1个）到汇点（出度=0，只有1个）的带权路径长度最大的路径称为关键路径。关键路径上的活动称为关键活动。
      - 应用：在项目管理中，关键路径法（Critical Path Method，CPM）用于确定项目的最短完成时间和关键活动，可以通过缩短关键活动的持续时间来缩短项目的整体工期。（当然，也不能缩短太多，因为需要重新计算关键路径了）
      - 过程：
      ![关键路径1](image-33.png)
      ![关键路径2](image-34.png)
      ![关键路径3](image-35.png)
      - 1.对图中顶点进行排序，按照拓扑排序求得每个事件的最早发生时间ve(i)，也就是从源点到vi的最长路径长度。
        - $\ ve(0) = 0，ve(i) = max{ve(k) + w(k,i)} ，<vk,vi> ∈T，1<= i <= n-1 $\
        - 其中w(k,i)为边<vk,vi>的权值，T为所有以vi为弧头的弧的集合。
        - 从源点往汇点递推
      - 2.对图中顶点进行逆拓扑排序，按照逆拓扑排序求得每个事件的最晚发生时间vl(i)，也就是从vi到汇点的最长路径长度。
        - $\ vl(n-1) = ve(n-1)，vl(i) = min{vl(k) - w(i,k)}，<vi,vk> ∈S, 0<= i <= n-2 $\
        - 其中w(i,k)为边<vi,vk>的权值，S为所有以vi为弧尾的弧的集合。
        - 从汇点往源点递推
      - 注意：ve(i)和vl(i)的max和min本质上都是对w取max！（因为max这里是正号，min这里是负号）
      - 3.计算每个活动ai= <vj,vk>的最早开始时间e(i)
        - e(i) = ve(j)，也就ai的起点vj的最早开始时间。因为只有时间vj开始了，活动ai才能开始。
      - 4.计算每个活动ai = <vj,vk>的最晚开始时间l(i)
        - l(i) = vl(k) - w(j,k)，也就是从ai的终点vk的最晚开始时间减去从vj到vk的边的权值。
      - 5.找出e(i)=l(i)的活动，从源点到汇点的这些活动就是关键活动，关键路径就是这些关键活动的集合。（可能不止一条关键路径）。e(i)-l(i)的值称为该活动的期限余量。

## Ch7_查找
### 1.基础知识
- 1.查找算法是在什么数据结构上作查找？
  - 散列表，也叫查找表这是一种新的数据结构，也是数据元素的有限集合，不过各元素之间的关系比较松散，没有太多严格的限制
- 2.什么是查找
  - 也就是我们给定一个值，在查找表上找到对应的数据元素内容或者记录
- 3.基础概念
  - 1.关键字：用于标识一个数据元素某个数据项的值
    - 1. 主关键字：通过关键字只能唯一的标识一个数据元素
    - 2. 次关键字：通过关键字标识的数据元素不止一个
  - 2.ASL（平均查找长度））：关键字的平均比较次数
    - 公式：$\ ASL = \sum_{i=1}^{n} p(i) \cdot c(i) $\ 
      - 其中p(i)为查找关键字i的概率，c(i)为查找关键字i的比较次数
  - 3.查找表的分类
    - 1. 静态查找表：只对查找表作查询和遍历操作，不会改变查找表，这时使用静态查找表（const）
    - 2. 动态查找表：对查找表要进行增删改的操作，会改变查找表
### 2.线性表的查找算法（更适用于静态查找表）
- 1.**顺序查找法（Sequential Search）**
  - 1.查找对象：顺序表（链表也是一个道理）
  ![顺序查找法](image-36.png)
  - 2.$\ ASL = \sum_{i=1}^{n} p(i) \cdot c(i)= \frac{n+1}{2} $，其中n为表中元素的个数
  - 2.优缺点
    - 1. 优点：算法简单，对数据的逻辑结构没有太多要求，对大多数数据结构都适用
    - 2. 缺点：ASL过长(n+1)/2，时间效率低
  - 注意事项：设置哨兵，让第0个位置的值为查找对象，从后往前查找，减少比较次数。

- 2.**二分（折半）查找（Binary Search）**
  - 1. 查找对象：顺序结构
  - 判定树
    - 用一颗二叉树表示顺序表中每个元素的查找的程序执行次数，把当前查找的元素作为根结点，左子树表示小于该元素的元素，右子树表示大于该元素的元素。每次比较都将查找范围缩小一半。
    - 性质：根据二叉树的性质，对于长度为n的有序表，二分查找的判定树的深度为 $\lfloor log_2(n) \rfloor + 1$，查找成功时的比较次数为 $\lfloor log_2(n) \rfloor + 1$，查找失败时的比较次数为 $\lfloor log_2(n) \rfloor + 2$。
    ![二分查找法的判定树](image-37.png)
  - 2.$\ ASL =  \sum_{i=1}^{n} p(i) \cdot c(i) = \sum_{j=1}^{h} j \cdot 2^{j-1} = (n+1)/n * log_2(n) ≈ log_2(n+1)-1, (n>50)$
    - 其中n为表中元素的个数，h为二分查找的深度，h= $\lfloor log_2(n) \rfloor + 1$。这里假定为满二叉树，所以 n = $2^h - 1$，即h= $\ log_2(n+1) $。
    - 公式过程可以用级数求和公式推导出来。
  - 3.优缺点
    - 1. 优点：算法简单，时间效率高O(log2(n))，ASL低，log2(n+1)-1(n&gt;50)
    - 2.缺点：
      - 数据结构必须得是顺序结构；表中的元素事前要进行排序
      - 有序表的插入和删除操作需要平均比较和移动一半的元素，时间复杂度为O(n)，因此不适合动态查找表（数据元素经常变动的线性表）

- 3.**分块查找（索引顺序查找）（Blocking Search）**
  - 分块查找的思想类似于小时候使用的新华字典先对关键字进行分块的查找，确定关键在哪一个大致的范围内再从那一个小范围内继续查找第一步确定分块采用的是二分查找，第二步在分块内查找用的是顺序查找
  - 定义：将数据表分成若干个块，建立索引表，索引表中存放每个块的最大关键字和起始位置，第二个子表的所有记录的关键字都大于第一个子表中的最大关键字，以此类推。
  - 特点：块间有序，块内可以无序。
  - ASL：如图。(用二分查找确定块，再用顺序查找确定块内的元素)
      ![分块查找性能分析](image-38.png)
  - 优缺点：
    - 1. 优点：查找效率还是蛮高的，至少是比顺序查找要高的由于数据本身可以采用链表存储，因为插入和删除比较方便
    - 2. 缺点：要单独建一个索引的表，并且要对索引表进行排序
- 4.对比3种查找算法：
  ![线性表3种查找方法比较](image-39.png)
### 树表的查找算法（更适用于动态表）
- ![数表的查找](image-40.png)
- 1.**二叉排序树（Binary Search Tree）**
  - 1.补充基础知识
    - 什么是二叉排序树
      - 二叉排序树是指：二叉树的左子树的所有元素的值都小于根结点，右子树的元素大于等于根结点左子树和右子树又是一颗二叉树
      - 对二叉排序树进行**中序遍历**，便能得到一个按照关键字排序的递增序列
    - 存储结构：二叉链表
  - 2.**基于二叉搜索树的查找算法**
    - 1.二叉搜索树本质上还是一个二叉树的遍历，遍历方式是DLR先序遍历
    - 时间复杂度：时间复杂度与二叉树的形态有关。
      - 如果二叉搜索树的形态是判定树，即树的深度为$\ log_2(n) $，那么二叉搜索树的查找时间复杂度O(log2n)。
      - 但是，如果二叉搜索树根结点的元素是最小的元素，那么二叉树会退化成一个全是右孩子的树（单支树，相当于单链表），其查找变成了顺序查找O(n)。
      - 因此，如果二叉排序树形态不好，就会影响我们查找的效率，因此我们要将二叉排序树转化成**平衡二叉树**
      - 与二分查找的对比：平均时间复杂度都是O(log2n)，但是二叉排序树的插入、删除操作时间复杂度是O(log2n)，而二分查找的插入、删除操作时间复杂度是O(n)，所以二叉排序树在插入和删除更高效，更适合动态查找表。
  - 3.二叉树排序的操作：
    - 删除（最麻烦）：
      - 假设要删除的结点为*p，其双亲结点为*f，假定*p为*f的左孩子（右孩子的情况类似）
      - 1.如果要删除的结点是叶子结点，直接删除即可:
        - f->lchild = NULL;
      - 2.如果要删除的结点只有一个子结点，直接将*p的子结点赋值给*f的左孩子即可:
        - f->lchild = p->lchild; 或者 f->lchild = p->rchild;
      - 3.如果要删除的结点有两个子结点，找到中序遍历里面*p的直接前驱（或者直接后继），替代*p的值，然后删除前驱结点（或者后继结点），此时算是递归删除。（这种方法不会增加树的深度）
        - p->data = s->data; q->rchild = s->lchild;(*s为*p的前驱结点，*q为*s的双亲结点,假设*s只有一个左孩子)
      ![二叉排序树的删除操作](image-42.png)
- 2.**平衡二叉树（AVL树）（Balanced Binary Tree）**
  - 1.平衡二叉树的定义
    - 一颗非空具有如下特征的二叉排序树：(1 )左子树和右子树的深度之差的绝对值不超过1;(2)左子树和右子树也是平衡二叉树。就可以称作平衡二叉树。
  - 最小不平衡子树的定义
    - 如果插入结点后破坏了平衡关系，那么离插入结点最近的失衡结点为根的子树被称为最小不平衡子树。
  - 2.4种非平衡二叉树的调整：假设最小不平衡子树的根节点为A，如图
    - L_L型
    - L_R型
    - R_L型
    - R_R型
    ![4种非平衡二叉树的调整](image-41.png)
  - 平衡因子（BF）与调整：
    - 在生成二叉排序树的时候，如果存在某个结点的平衡因子绝对值大于1，那么就需要对该结点的树进行调整，
    - 如果有多个结点都出现该情况，我们只需要去调整最小的失衡二叉树即可将整棵树调整好
- 3.B-树（B-Tree）(平衡有序多路m叉查找树)
  - 定义：B-树是一种自平衡的多路查找树，具有以下特征：
    - 1.每个结点可以有多个子结点（m叉树），m称为B-树的阶。
    - 2.每个结点包含多个关键字，关键字按升序排列。
    - 3.所有叶子结点都在同一层。
    - 4.非叶子结点至少有⌈m/2⌉个子结点，除根结点外，其他结点至少有⌈m/2⌉-1个关键字。
    - 5.根结点至少有两个子结点（除非是空树）。
  ![B-树](image-43.png)
  - 特点：
    - B-树适用于磁盘存储和大规模数据处理，能够有效地减少磁盘I/O操作，用于外查。（之前的二叉树都是内存查找）。
    - 一个结点允许多个数据域，这是硬件特点导致的（读取多个字节不变慢）。
    - 访问结点在外存进行，结点内的查找是内存查找。外查可能是内查耗时的百万倍。
  - 结点的分支与元素数的范围
    - Max：m个分支，m-1个元素
    - Min：
      - 根结点：2个分支，1个元素
      - 非根结点：⌈m/2⌉个分支，⌈m/2⌉-1个元素
  - 应用：数据库索引、文件系统等。
  - 操作：
    - 插入：
      - 在合适的叶子结点进行插入一个关键字，如果满足关键字个数≤m-1，则直接插入；如果不满足，则需要进行分裂操作，将该结点分裂成两个结点，并将中间的关键字上升到父结点，然后不断递归向上调整，直到根结点。
      - 可能有上溢的情况，根结点分裂后会导致树的高度增加。
    - 删除：
      - 类似二叉排序树的删除操作，可能会用到合并和替换操作。3种情况：
        - 删除后，如果满足结点关键字个数≥⌈m/2⌉-1，则直接删除；
        - 兄上去，父下来：如果不满足结点关键字个数≥⌈m/2⌉-1，但相邻的兄弟结点关键字个数＞⌈m/2⌉-1，则可以让兄弟结点的最小（最大）关键字上升到双亲结点，并将双亲结点中小于（或大于）且紧靠该上移关键字的关键字下移到被删关键字所在结点。
        - 合并：如果不满足结点关键字个数≥⌈m/2⌉-1，且相邻的所有兄弟的结点关键字个数都=⌈m/2⌉-1，则可以将该结点与兄弟结点合并，并将父结点中小于（或大于）且紧靠该兄弟结点的关键字下移到合并后的结点中。如果双亲结点的关键字个数也不满足≥⌈m/2⌉-1，则需要向上递归合并，直到根结点。
      - 可能有下溢的情况，可能会导致树的高度减少。
      ![B-树的删除](image-44.png)
- 4.B+树（B+ Tree）
  - 定义：B+树是B-树的一种变体，具有以下特征：
    - 1.所有关键字都存储在叶子结点中，非叶子结点只存储子树的最大（最小）关键字。
    - 2.叶子结点之间通过指针相连，形成一个有序链表。
    - 3.非叶子结点的关键字个数与B-树相同。
    - 4.有n颗子树的结点有n个关键字。（与B-树不同，B-树是n-1个关键字）
  ![B+树](image-45.png)
  - 特点：
    - B+树适用于范围查询和区间查询，因为所有关键字都在叶子结点中，并且叶子结点之间有指针连接。
    - B+树的查找效率更高，因为非叶子结点只存储索引信息，减少了内存占用。
    - 既可以进行顺序查找（从最小关键字的叶子结点的指针sqt开始），也可以进行随机查找（从根节点指针root开始）。顺序查找可以避免只能通过中序遍历才能找齐所有关键字的问题。
  - 应用：数据库索引、文件系统等。
  - 操作
    - 插入和删除操作与B-树类似，但由于所有关键字都在叶子结点中，插入和删除操作只影响叶子结点，不会影响非叶子结点的结构。
    - 插入：
      - 在合适的叶子结点进行插入一个关键字，如果满足关键字个数>=m,则分裂成2个结点，关键字个数分别是⌊m+1/2⌋和⌈m+1/2⌉，双亲结点应该同时包含两个结点的最大（最小）关键字。
    - 删除：
      - 类似B-树的删除操作，但只影响叶子结点，不会影响非叶子结点的结构。
      - 删除后，如果满足结点关键字个数>=⌈m/2⌉，则直接删除；如果不满足，则需要进行合并或借用操作。（与B-树类似）

### 4.基于散列表的查找算法
- 1.什么是散列表
  - 1.散列表是一种存储结构，其元素的存储位置是通过一个散列函数（Hash函数）将元素的关键值与存储位置形成一个映射
  - 2.常用的Hash函数（散列函数）
    - 1.**除留余数法**（最常用）：
      - 定义: 用元素的关键值除以一个数m，m通常小于等于要存放的数的元素个数，
      - 公式：H(k)=key mod m
      ![除留余数法](image-46.png)
    - 2.直接定址法：用元素关键值除以一个系数得到除数，常记作 H(k)=key/a+b
    - 3.数字分析法：需要事先知道所有关键字每一位上各种数字的分布情况，适用于ISBN码等特定的关键字
    - 4.平方取中法：将关键字平方后取中间几位作为散列地址
    - 5.折叠法：将关键字分成位数相同的几部分（最后一部分位数可以不同），叠加求和，然后取模得到散列地址
    - 6.随机数法
- 2.散列表存储时的冲突问题
  - 1.为什么会产生冲突？
  元素关键字通过哈希函数生成的存储地址有可能会发生重叠，同一位置有多个元素要存放，这便是冲突。如何解决冲突？
  - 2.解决冲突的方式：
    - 1.开放定址法（开地址法）
      - 开放定址法的基本思想是：把记录都存储在散列表数组中，当某一记录关键字 key的初始散列地址H0=H(key)发生冲突时，以H0为基础 ，采取合适方法计算得到另一个地址H1, 如果H1仍然发生冲突，以H1为基础再求下一个地址H2，若H2仍然冲突，再求得H3。依次类推，直至Hk不发生冲突为止，则Hk为该记录在表中的散列地址。
      - 公式：H(i) = (H(key) +d(i)) mod m
        - 其中d(i)为探测函数，i为探测次数，m为散列表的长度。
      - 开放定址法的几种探测方法：
        - 1.线性探测法：
          - 如果存放位置有冲突，探索该位置的下一个地址，以此类推。
          - d(i) = i,i<=m
        - 2.二次探测法：
          - 以1^2, -1^2, 2^2, -2^2依次往下探测。
          - d(i) = 1^2, -1^2, 2^2, -2^2，..., (i<= m/2)
        - 3. 伪随机探测法: 
          - 通过一个伪随机数生成器生成一个随机数作为探测函数。
          - d(i) = 随机数
      ![开放定址法](image-47.png)
    - 2.链地址法（拉链法）。
      - 链地址法的基本思想是：把具有相同散列地址的记录放在同一个单链表中，称为同义词链表。有 m 个散列地址就有 m 个单链表，同时用数组 HT[O…m-1]存放各个链表的头指针，凡是散列地址为 l 的记录都以结点方式插入到以 HT[i]为头结点的单链表中。
      ![链地址法](image-48.png)
      ![链地址法例子](image-49.png)
- 3.散列表的查找
  - 散列表的查找其实就是散列表的生成过程
    - 散列表查找性能分析
      - 1.散列函数（Hash函数）
        - 除留余数法好于其他散列函数。
      - 2.冲突解决方法
        - 链地址解决冲突要比开放地址法好
      - 3.装填因子=表中填入元素的个数/散列表的长度。直观的来说，装填因子越小，一般发生冲突的可能性也就越小
    ![散列表的查找性能分析1](image-50.png)
    ![散列表的查找性能分析2](image-51.png)
    - ASL公式
      - 查找成功：
        - ASL = $ \frac{1}{n} \sum_{i=1}^{n} C(i) $
        - 其中C(i)为查找第i个元素的比较次数，n为散列表中记录的个数。
      - 查找失败：
        - ASL = $ \frac{1}{r} \sum_{i=1}^{n} C(i)$
        - 其中C(i)为查找第i个元素的比较次数，r为散列函数取值的个数。
## Ch8_排序
### ![排序总结](image-52.png)
### 1. 插入排序
- 1.用顺序查找法确定插入位置：**直接插入排序**
  - 1. 将第一个还没有排序的元素与它之前已经排好的那部分序列，从有序序列的后面开始，依次比较，直到找到第一个小于该元素的元素，在这个小元素的后面插入
  - 2. 时间复杂度：O(n^2)，空间复杂度：O(1)
  ![直接插入排序](image-53.png)
- 2.用二分查找法确定插入位置：**折半插入排序**
  - 1. 将第一个还未排序的元素，在它之前的有序序列中，进行二分查找，二分查找会不断的缩小比较区间，直至缩小到只有一个元素的区间，该元素的位置+1就是未排元素的插入位置
  - 2. 时间复杂度：O(n^2)，空间复杂度：O(1)
  - 3. 二分插入要比直接插入在平均时间效率上好一点。只能比较平均时间效率，因为直接插入排序最好情况是O(n)，最好的ASL=1最差情况是O(n^2)，最坏的ASL=i-1但是二分插入排序的ASL都是||log2i||+1，所以只能比较平均时间效率
  ![折半插入排序](image-54.png)
- 3.缩小增量，多遍插入排序：**希尔排序**
  - 1. 设置一个增量序列，让待排元素按照一个特定的值分组进行排序，不断减小分组的间隔，最后就能得到一个排好序的序列
  - 2. 时间复杂度：没有严格的数学证明，但是猜想为O(n^1.25)~1.6O(n^1.25)之间
  - 3. 希尔排序是一种不稳定的排序，直接插入排序和二分插入排序都是稳定的排序
  ![希尔排序](image-55.png)
### 2. 交换排序
- 1.**冒泡排序**
  - 冒泡排序不多说了，学C语言的时候就已经学过了
  - 时间复杂度：O(n^2)，空间复杂度：O(1)
  ![冒泡排序（改进）](image-56.png)
- 2.**快速排序**
  - 原理讲起来有些复杂，不过基本思想类似于二叉树的遍历，都是要使用递归函数来解决问题。简单来说，是在无序序列中找一个中枢点，将小于中枢点的放在中枢点左边，大于中枢点的放在中枢点右边，再对中枢点左边的重复刚刚那个步骤，再对右边的重复那个步骤。。。一直持续下去，直到无序序列长度为1，
  - 时间复杂度：O(nlogn)，空间复杂度O(nlogn)
  - 快速排序不是一种稳定的排序方式。其次，快速排序不适用于有一定顺序的序列，否则快排将会退化成冒泡排序，因此，序列越乱，使用快速排序的效果越好
  ![快速排序1](image-57.png)
  ![快速排序2](image-58.png)
### 3. 选择排序
- 1.**直接选择排序**
  - 算法思路很简单，每次从序列中拿出一个最小值，依次往复，就能排好序
  - 时间复杂度：O(n^2)，空间复杂度：O(1)
  - 直接选择排序不是一个稳定的算法
  ![直接选择排序](image-59.png)
- 2.**堆排序**
  - 1.什么是堆
    - 堆分为大根堆和小根堆大根堆是指，对于一个完全二叉树，其每一个结点的值大于结点孩子的值小根堆和大根堆的比较相反，结点小于孩子的值
  - 2.如何由无序序列创建一个堆
    - 首先，我们是用一个顺序存储结构保存这个完全二叉树，完全二叉树的双亲和孩子是通过下标位置联系再一起的（双亲i，左孩子2i，右孩子2i+1），
    - 先把无序序列依次保存在顺序存储结构中然后从完全二叉树的最后一个非叶子结点开始，比较结点的值和孩子的值，让结点值交换成最小的值，每次交换要一直延续到叶子结点重复上面的过程，一直到根结点
  - 3.有了堆之后，如何输出有序序列
    - 先输出完全二叉树的顶点的值，然后完全二叉树变成了两个树，再将这两个树重新建立成新的堆的完全二叉树，在输出顶点，再建二叉树，循环往复直到最后一个结点
  ![堆排序1](image-60.png)
  ![堆排序2](image-61.png)
### 4. **归并排序**
- 自底向上的归并排序：归并排序的思想：用单个元素的序列开始，两两一对排序形成新序列，再把两个元素的序列两两组成一对，再排序，形成四个有序元素的序列，一直这样循环往复，逐渐得到一个完整的有序序列
- 自顶而下的归并排序：使用递归思想，分而治之，将大数组的排序分成若干个小数组的排序，再把这些小数组重新合并成一个打的大的有序数组
- 自顶而下是把整打撒成零、自底向上是把零归纳成整。两者方向相反，但是还是有共同之处。掌握了一个就能反推另一个。
![归并排序](image-62.png)
### 5. **基数排序（桶排序）**
- 1.基数排序的思想
  - 基数排序是将待排序的元素按照位数进行分组，从低位到高位依次进行排序，直到所有位数都排序完成。
  - 基数排序可以看作是多次的桶排序，每次对一个位进行排序。
- 2.基数排序的步骤
  - 1. 确定待排序元素的最大位数。
  - 2. 从最低位开始，对每一位进行桶排序。
  - 3. 重复步骤2，直到所有位数都排序完成。
- 3.基数排序的特点
  - 基数排序是一种稳定的排序算法，因为在每一位的桶排序中，元素的相对顺序不会改变。
  - 基数排序的时间复杂度为O(d * (n + k))，其中d为最大位数，n为待排序元素个数，k为桶的数量。空间复杂度为O(n + k)。
  - 基数排序适用于大规模数据的排序，但需要额外的空间来存储桶。
![基数排序](image-63.png)