/***********************************************************
 * 第4章  串、数组和广义表
 ***********************************************************/

// 参考来源：
// 1. 课本：《数据结构 C语言第二版》by 严蔚敏；p109-p110；
// 2. 习题：《数据结构习题解析与实验指导》by 李冬梅。 p82-p86；

//导入相关的头文件
# include <stdio.h> // 标准输入输出流
# include <iostream> // 输入输出流
using namespace std; // 使用标准命名空间   
// Status定义
#define OK 1
#define ERROR 0 
#define OVERFLOW -2
typedef int Status; // Status是函数的类型，其值是函数结果状态代码


/*==================================
* 算法设计题（见习题集)
 *==================================*/


 /* ---------- Start of 定义 ---------- */
// 定义链队列结点
// 参考课本：p73
typedef struct QNode{
    int data; // 数据域。int本来应该是QElemType
    struct QNode *next; // 指针域
}QNode, *QueuePtr;
 /* ---------- End of 定义 ---------- */


// 1. 写一个算法统计输入字符串中各个字符出现的次数，并将结果存入文件。字符串中的合法字符为A-Z、0-9。
// 思路：ASCII码表，哈希表。
//  - 参考习题：p82-p83；

void Count(){
    // num初始化
    int num[36]; // 统计字符出现次数的数组
    int i; // 定义变量i
    for (i = 0; i < 36; i++) num[i] = 0; // 初始化数组
    // 读入字符串
    char ch;
    while((ch=getchar())!='\0') { // 读入字符，直到遇到'\0'为止。getchar()函数从标准输入流中读取一个字符。
        if(ch>='A'&&ch<='Z'){
            i = ch-'A'+ 10; // 字母A-Z对应的下标为10-35. 改成i= ch-65+10 也可以。因为A的ASCII码是65。
            num[i]++; // 统计字母出现次数
        }
        else if(ch>='0'&&ch<='9'){
            i = ch-'0'; // 数字0-9对应的下标为0-9。改成i= ch-48 也可以。因为0的ASCII码是48。
            num[i]++; // 统计数字出现次数
        }
    }
    for(i = 0; i < 10; i++){
        cout << "数字" << i << "出现次数：" << num[i] << endl; // 输出数字出现次数
    }
    for(i = 10; i < 36; i++){
        cout << "字母" << (char)(i-10+'A') << "出现次数：" << num[i] << endl; // 输出字母出现次数
    }
}

// 2. 写一个递归算法实现字符串逆序存储，要求不另设串存储空间
// 思路：递归
// - 参考习题：p83

void Inverse(char A[]){
    // 递归实现字符串逆序存储
    static int i = 0; // 静态变量i，初始值为0，记录字符数组下标,相当于全局变量。这样方便实现逆序
    
    char ch;
    cin >> ch; // 读入字符
    if(ch!='.'){ // 如果不是结束标志'.'，则递归调用
        Inverse(A); // 递归调用函数本身，实现逆序，因为A[i++] 在Inverse(A)的后面。
        A[i++] = ch; // 将字符存入数组.A[i++] =ch表示先赋值再自增。相当于A[i]=ch; i++;。
    }
    A[i] = '\0'; // 字符串结束标志，相当于如果ch=='.'，则A[i]='\0',一般会是A[0]='\0'。一般'\0'表示字符串结束,但是逆序存储时，'\0'变成了字符串开始标志。
    // 这行其实是相当于递归停止时的情况。
}

// 3.编写算法，实现下面的函数功能。 void insert(char *s,char *t, int pos); 将字符串t插入到字符串s的pos位置处。假设分配给s的存储空间足够大。
//   说明：不得使用库函数。
//   参考习题：p83-84；

void insert(char *s, char *t, int pos){ // 插入字符串
    char *p, *q; // 定义指针p和q
    p = s, q = t; // 分别指向字符串s和t
    int i = 1,x=0,j; // 定义计数器i,x,j

    // 先判断pos位置是否合法：1<=pos<=strlen(s)
    if(pos<1) {
        cout << "插入位置不合法" << endl; // 插入位置不合法
        exit(0); // 退出程序
    }
    while(*p != '\0' && i< pos){ // 查找pos位置 
        p++; // 指针p后移
        i++; // 计数器i后移
    }
    if(* p == '\0') { // 如果p指向'\0'，说明pos位置大于字符串s的长度，即pos位置不合法
        cout << "插入位置大于字符串s长度" << endl; // 插入位置不合法
        exit(0); // 退出程序
    }

    // 下面是插入操作
    while(*p != '\0'){ // 查找字符串s的结束位置。查到串尾时，i为字符'\0'的位置（i的初始值为1而不是0），p指向'\0'.
        p++; // 指针p后移
        i++; // 计数器i后移
    }
    while(*q != '\0'){ // 查找字符串t的结束位置,得到t的长度x（x初始值为0而不是1），结束时q指向'\0'.
        q++; // 指针q后移
        x++; // 计数器x后移
    }
    for(j =i; j >= pos; j--){ // 将字符串s的pos位置到结束位置的字符后移x个位置(闭区间[pos,i])
        *(p + x) = *p; // 将字符串s的pos位置到结束位置的字符后移x个位置
        p--; // 指针p前移
    } // 结束时，p指向 pos位置前1位
    q --; // 指针q前移1位，指向字符串t的最后一个字符而不是'\0'.
    p = p + x; // 指针p重新指向字符串s的pos-1+x位置处，准备从后往前插入字符串t的字符。
    // 插入的位置是s的[pos,pos-1+x]闭区间，共x个字符。从t的 [1,x] 的位置从后往前插入。
    for( j = 1; j <= x; j++){ // 将字符串t（长度x）插入到字符串s的pos位置处
        *p-- = *q--; // 相当于 *p = *q; p--, q--;
    }
}

// 4.字符串S1存放了一段英文，请写出算法format(s1,s2,s3,n),将其按照给定的长度n格式化为两端对齐的字符串S2,（即长度为n且首尾元素不为空格）
//    多余字符存放在字符串S3中。
// 思路：首先从左往右扫描字符串S1，找到第一个非空格字符的位置，计数到n；
//      - 然后判断第n个烤入字符串s2的字符不得为空格，最后将余下的字符存入字符串s3。
// 参考习题：p84-85；

void Format(char *s1, char *s2, char *s3, int n){ // 格式化字符串
    char *p = s1, *q = s2; // 定义指针p和q，分别指向字符串s1和s2
    int i = 1; // 定义计数器i
    while( *p == ' ') p++; // 过滤掉左端所有的空格字符，直到遇到第一个非空格字符为止。p指向第一个非空格字符。隐含了!*p != '\0'的条件。
    if(*p == '\0') { 
        cout << "字符串s1为空格串或者空串" << endl; // 字符串s1为空格串或者空串
        exit(0); // 退出程序
    }
    while(*p != '\0' && i < n){ // 先将s1的前n-1个有效非空字符复制到s2中（第n个需要后面再判断是否是空格）。i从1开始到n-1
        *q = *p;  
        i++,p++,q++; // 计数器i和指针p,q都后移1位。循环结束时i应=n，p指向第n个有效非空格字符，q指向s2的第n个字符。
    }
    if (p == '\0') { // 如果字符串s1的有效非空格长度小于n，则直接返回
        cout << "字符串s1的有效非空格长度小于" << n << endl; 
        exit(0); // 退出程序
    }
    while(*p==' ') p++;  // 过滤掉右端所有的空格字符，直到遇到第一个非空格字符。该条件隐含了!* p != '\0'的条件。
    if(*p == '\0') { // 如果字符串s1的第n个字符是空格，且后面没有非空格字符
        cout << "字符串s1没有"<<n <<"个两端对齐的字符串"<< endl; // 字符串s1的第n个字符是空格，且后面没有非空格字符
        exit(0); // 退出程序
    }
    *q = *p; // 复制s2的最后一个非空字符。赋值位置是第n个有效非空格字符。
    q = s3; // 指针q重新指向字符串s3
    p++; // 指针p后移1位，到第n+1个有效非空格字符。
    while (*p != '\0') { // 将字符串s1中剩余的字符存入字符串s3中
        *q++ = *p++;
    }
    *q = '\0'; // 字符串s3结束标志
}

// 5.设二维数组a[1...m,1...n]含有m*n个整数。
//  5.1 编写算法，判断a中所有元素是否互不相同。输出关键信息（yes或no）。
//  5.2 分析算法的时间复杂度。
//  思路：依次遍历数组每个元素，对于第i行的每个元素，先同本行后面的元素比较，然后再同第i+1行及其后各行的元素比较。
//       只要找到相同的元素，就返回no，否则返回yes。
//       - 不过如果学了字典，可以哈希表
// 参考习题：p85-86；
// 时间复杂度：O(n**4)，其中n为数组的列数。

int IsEqual(int m, int n, int (*a)[100]) { // Replace 100 with the maximum column size of your array
    int i, j, k,p; // 定义变量i,j,k
    for(i=0;i<m;i++){ // 遍历行
        for(j=0;j<n-1;j++){ // 遍历列。注意是n-1，因为要和后面的元素比较
            for(p=j+1;p<n;p++){ // 与同行其他元素比较. 注意是p=j+1，而不是p=j，因为要和同行后面的元素比较。
                if(a[i][j] == a[i][p]){ // 如果同一行的元素相等，则返回no
                    cout << "no" << endl; // 输出no
                    return 0; // 返回0，表示不相等
                }
        }
        for(k=i+1;k<m;k++){ // 与其他行的元素比较
            for(p=0;p<n;p++){ // 遍历列。注意是p=0和p<n，因为是其他行了。
                if(a[i][j] == a[k][p]){ // 如果同行的元素相等，则返回no
                    cout << "no" << endl; // 输出no
                    return 0; // 返回0，表示不相等
                }
            }
        }
    }
}
    cout << "yes" << endl; // 输出yes
    return 1; // 返回1，表示相等
} // 结束函数

// 时间复杂度分析：
//  - 二维数组有m行n列，共有m*n个元素，每个元素与其他元素比较1次。
//  - 在元素都不相同的情况下，共计比较 1+2+3+...+m*n-1 = m*n*(m*n-1)/2次。
//  - 在元素存在相同的情况下，可能在第1次比较时就找到相同的元素，返回no；也可能在最后一次比较时才找到相同的元素，返回yes，假设概率相同，
//  - 假设在每个位置上可能性相同，总计有m*n-1个位置，则平均比较次数大约为(m*n)(m*n-1)/4次。
//  - 因此时间复杂度为O(n**4)，其中n为数组的列数。

// 6. 设任意n个整数存放于数组A[1....n]中，试编写算法,将所有正数移到负数前面（要求：时间复杂度为O(n))
// 参考习题：p86；
// 思路：双指针法。

void Partition(int A[], int n) { // A是数组，n是数组长度
    int low = 1, high = n; // 定义两个指针，low指向第一个元素，high指向最后一个元素
    while (low < high) { // 当low指针小于high指针时循环
        while (A[low] > 0 && low < high) low++; // 如果A[low]大于0，则low指针后移.结束时A[low]小于0，指向第一个负数。
        while (A[high] < 0 && low < high) high--; // 如果A[high]小于0，则high指针前移.结束时A[high]大于0，指向第一个正数。
        if (low < high) { // 如果low指针小于high指针，则交换A[low]和A[high]
            int temp = A[low]; // 定义临时变量temp
            A[low] = A[high]; // 交换A[low]和A[high]
            A[high] = temp; // 将temp赋值给A[high]
        }
    }
}
// 结束函数